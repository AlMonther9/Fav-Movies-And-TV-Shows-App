import { type NextRequest, NextResponse } from "next/server"

// This would typically connect to your MySQL database
// For demo purposes, we'll use mock data

interface MediaEntry {
  id: number
  title: string
  type: "Movie" | "TV Show"
  director: string
  budget: string
  location: string
  duration: string
  year: string
  genre: string
  description: string
  rating: number
  createdAt: string
}

// Mock database
const mockDatabase: MediaEntry[] = [
  {
    id: 1,
    title: "Inception",
    type: "Movie",
    director: "Christopher Nolan",
    budget: "$160M",
    location: "Los Angeles, Paris",
    duration: "148 min",
    year: "2010",
    genre: "Sci-Fi",
    description:
      "A thief who steals corporate secrets through dream-sharing technology is given the inverse task of planting an idea into the mind of a C.E.O.",
    rating: 5,
    createdAt: new Date().toISOString(),
  },
  {
    id: 2,
    title: "Breaking Bad",
    type: "TV Show",
    director: "Vince Gilligan",
    budget: "$3M/ep",
    location: "Albuquerque",
    duration: "49 min/ep",
    year: "2008-2013",
    genre: "Drama",
    description:
      "A high school chemistry teacher diagnosed with inoperable lung cancer turns to manufacturing and selling methamphetamine.",
    rating: 5,
    createdAt: new Date().toISOString(),
  },
]

// GET - Fetch media entries with pagination
export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url)
  const page = Number.parseInt(searchParams.get("page") || "1")
  const limit = Number.parseInt(searchParams.get("limit") || "10")
  const search = searchParams.get("search") || ""
  const type = searchParams.get("type") || "all"

  let filteredEntries = mockDatabase

  // Apply search filter
  if (search) {
    filteredEntries = filteredEntries.filter(
      (entry) =>
        entry.title.toLowerCase().includes(search.toLowerCase()) ||
        entry.director.toLowerCase().includes(search.toLowerCase()) ||
        entry.genre.toLowerCase().includes(search.toLowerCase()),
    )
  }

  // Apply type filter
  if (type !== "all") {
    filteredEntries = filteredEntries.filter((entry) => entry.type === type)
  }

  // Apply pagination
  const startIndex = (page - 1) * limit
  const endIndex = startIndex + limit
  const paginatedEntries = filteredEntries.slice(startIndex, endIndex)

  return NextResponse.json({
    entries: paginatedEntries,
    totalCount: filteredEntries.length,
    hasMore: endIndex < filteredEntries.length,
    page,
    limit,
  })
}

// POST - Create new media entry
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()

    // Validate required fields
    if (!body.title || !body.director || !body.type) {
      return NextResponse.json({ error: "Missing required fields: title, director, type" }, { status: 400 })
    }

    const newEntry: MediaEntry = {
      id: Date.now(), // In real app, this would be auto-generated by database
      title: body.title,
      type: body.type,
      director: body.director,
      budget: body.budget || "",
      location: body.location || "",
      duration: body.duration || "",
      year: body.year || "",
      genre: body.genre || "",
      description: body.description || "",
      rating: body.rating || 5,
      createdAt: new Date().toISOString(),
    }

    mockDatabase.unshift(newEntry) // Add to beginning of array

    return NextResponse.json(newEntry, { status: 201 })
  } catch (error) {
    return NextResponse.json({ error: "Invalid request body" }, { status: 400 })
  }
}
